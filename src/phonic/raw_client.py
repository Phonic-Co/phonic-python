# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.http_response import AsyncHttpResponse, HttpResponse
from .core.jsonable_encoder import jsonable_encoder
from .core.pydantic_utilities import parse_obj_as
from .core.request_options import RequestOptions
from .core.serialization import convert_and_respect_annotation_metadata
from .errors.bad_request_error import BadRequestError
from .errors.conflict_error import ConflictError
from .errors.forbidden_error import ForbiddenError
from .errors.gateway_timeout_error import GatewayTimeoutError
from .errors.internal_server_error import InternalServerError
from .errors.not_found_error import NotFoundError
from .errors.unauthorized_error import UnauthorizedError
from .types.basic_error import BasicError
from .types.conversation_evaluation_result import ConversationEvaluationResult
from .types.create_agent_request_audio_format import CreateAgentRequestAudioFormat
from .types.create_agent_request_configuration_endpoint import CreateAgentRequestConfigurationEndpoint
from .types.create_agent_request_template_variables_value import CreateAgentRequestTemplateVariablesValue
from .types.create_agent_request_tools_item import CreateAgentRequestToolsItem
from .types.create_tool_request_execution_mode import CreateToolRequestExecutionMode
from .types.create_tool_request_type import CreateToolRequestType
from .types.delete_agents_name_or_id_response import DeleteAgentsNameOrIdResponse
from .types.delete_extraction_schemas_name_or_id_response import DeleteExtractionSchemasNameOrIdResponse
from .types.delete_projects_name_or_id_response import DeleteProjectsNameOrIdResponse
from .types.delete_tools_name_or_id_response import DeleteToolsNameOrIdResponse
from .types.error import Error
from .types.extraction_field import ExtractionField
from .types.get_agents_name_or_id_response import GetAgentsNameOrIdResponse
from .types.get_agents_response import GetAgentsResponse
from .types.get_conversations_id_analysis_response import GetConversationsIdAnalysisResponse
from .types.get_conversations_id_evals_response import GetConversationsIdEvalsResponse
from .types.get_conversations_id_extractions_response import GetConversationsIdExtractionsResponse
from .types.get_conversations_id_response import GetConversationsIdResponse
from .types.get_conversations_response import GetConversationsResponse
from .types.get_extraction_schemas_name_or_id_response import GetExtractionSchemasNameOrIdResponse
from .types.get_extraction_schemas_response import GetExtractionSchemasResponse
from .types.get_projects_id_conversation_eval_prompts_response import GetProjectsIdConversationEvalPromptsResponse
from .types.get_projects_name_or_id_response import GetProjectsNameOrIdResponse
from .types.get_projects_response import GetProjectsResponse
from .types.get_tools_name_or_id_response import GetToolsNameOrIdResponse
from .types.get_tools_response import GetToolsResponse
from .types.get_voices_id_response import GetVoicesIdResponse
from .types.get_voices_response import GetVoicesResponse
from .types.outbound_call_config import OutboundCallConfig
from .types.patch_agents_name_or_id_response import PatchAgentsNameOrIdResponse
from .types.patch_extraction_schemas_name_or_id_response import PatchExtractionSchemasNameOrIdResponse
from .types.patch_projects_name_or_id_response import PatchProjectsNameOrIdResponse
from .types.patch_tools_name_or_id_response import PatchToolsNameOrIdResponse
from .types.post_agents_response import PostAgentsResponse
from .types.post_conversations_id_cancel_response import PostConversationsIdCancelResponse
from .types.post_conversations_id_extractions_response import PostConversationsIdExtractionsResponse
from .types.post_conversations_outbound_call_response import PostConversationsOutboundCallResponse
from .types.post_conversations_sip_outbound_call_response import PostConversationsSipOutboundCallResponse
from .types.post_extraction_schemas_response import PostExtractionSchemasResponse
from .types.post_projects_id_conversation_eval_prompts_response import PostProjectsIdConversationEvalPromptsResponse
from .types.post_projects_response import PostProjectsResponse
from .types.post_tools_response import PostToolsResponse
from .types.put_agents_upsert_response import PutAgentsUpsertResponse
from .types.task import Task
from .types.tool_parameter import ToolParameter
from .types.update_agent_request_audio_format import UpdateAgentRequestAudioFormat
from .types.update_agent_request_configuration_endpoint import UpdateAgentRequestConfigurationEndpoint
from .types.update_agent_request_template_variables_value import UpdateAgentRequestTemplateVariablesValue
from .types.update_agent_request_tools_item import UpdateAgentRequestToolsItem
from .types.update_tool_request_execution_mode import UpdateToolRequestExecutionMode
from .types.update_tool_request_type import UpdateToolRequestType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPhonic:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_agents(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAgentsResponse]:
        """
        Returns all agents in a project.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list agents for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAgentsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAgentsResponse,
                    parse_obj_as(
                        type_=GetAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_agents(
        self,
        *,
        name: str,
        project: typing.Optional[str] = None,
        phone_number: typing.Optional[typing.Literal["assign-automatically"]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[str] = OMIT,
        audio_format: typing.Optional[CreateAgentRequestAudioFormat] = OMIT,
        audio_speed: typing.Optional[float] = OMIT,
        welcome_message: typing.Optional[str] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        template_variables: typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]] = OMIT,
        tools: typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]] = OMIT,
        tasks: typing.Optional[typing.Sequence[Task]] = OMIT,
        no_input_poke_sec: typing.Optional[int] = OMIT,
        no_input_poke_text: typing.Optional[str] = OMIT,
        no_input_end_conversation_sec: typing.Optional[int] = OMIT,
        boosted_keywords: typing.Optional[typing.Sequence[str]] = OMIT,
        configuration_endpoint: typing.Optional[CreateAgentRequestConfigurationEndpoint] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostAgentsResponse]:
        """
        Creates a new agent in a project.

        Parameters
        ----------
        name : str
            The name of the agent. Can only contain lowercase letters, numbers and hyphens. Must be unique within the project.

        project : typing.Optional[str]
            The name of the project to create the agent in.

        phone_number : typing.Optional[typing.Literal["assign-automatically"]]

        timezone : typing.Optional[str]
            The timezone of the agent. Used to format system variables like `{{system_time}}`.

        voice_id : typing.Optional[str]
            The voice ID to use.

        audio_format : typing.Optional[CreateAgentRequestAudioFormat]
            The audio format of the agent.

        audio_speed : typing.Optional[float]
            The audio speed of the agent.

        welcome_message : typing.Optional[str]
            Message to play when the conversation starts. Can contain template variables like `{{customer_name}}`.

        system_prompt : typing.Optional[str]
            Instructions for the conversation. Can contain template variables like `{{subject}}`.

        template_variables : typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]]
            Variables that can be used in the welcome message and the system prompt.

        tools : typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]]
            Array of built-in or custom tool names to use.

        tasks : typing.Optional[typing.Sequence[Task]]
            Array of task objects with `name` and `description` fields.

        no_input_poke_sec : typing.Optional[int]
            Number of seconds of silence before sending a poke message. `null` disables the poke message.

        no_input_poke_text : typing.Optional[str]
            The message to send after the specified silence.

        no_input_end_conversation_sec : typing.Optional[int]
            Seconds of silence before ending the conversation.

        boosted_keywords : typing.Optional[typing.Sequence[str]]
            These words, or short phrases, will be more accurately recognized by the agent.

        configuration_endpoint : typing.Optional[CreateAgentRequestConfigurationEndpoint]
            When not `null`, at the beginning of the conversation the agent will make a POST request to this endpoint when to get configuration options.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostAgentsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "phone_number": phone_number,
                "timezone": timezone,
                "voice_id": voice_id,
                "audio_format": audio_format,
                "audio_speed": audio_speed,
                "welcome_message": welcome_message,
                "system_prompt": system_prompt,
                "template_variables": convert_and_respect_annotation_metadata(
                    object_=template_variables,
                    annotation=typing.Dict[str, CreateAgentRequestTemplateVariablesValue],
                    direction="write",
                ),
                "tools": convert_and_respect_annotation_metadata(
                    object_=tools, annotation=typing.Sequence[CreateAgentRequestToolsItem], direction="write"
                ),
                "tasks": convert_and_respect_annotation_metadata(
                    object_=tasks, annotation=typing.Sequence[Task], direction="write"
                ),
                "no_input_poke_sec": no_input_poke_sec,
                "no_input_poke_text": no_input_poke_text,
                "no_input_end_conversation_sec": no_input_end_conversation_sec,
                "boosted_keywords": boosted_keywords,
                "configuration_endpoint": convert_and_respect_annotation_metadata(
                    object_=configuration_endpoint,
                    annotation=CreateAgentRequestConfigurationEndpoint,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostAgentsResponse,
                    parse_obj_as(
                        type_=PostAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def put_agents_upsert(
        self,
        *,
        name: str,
        project: typing.Optional[str] = None,
        phone_number: typing.Optional[typing.Literal["assign-automatically"]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[str] = OMIT,
        audio_format: typing.Optional[CreateAgentRequestAudioFormat] = OMIT,
        audio_speed: typing.Optional[float] = OMIT,
        welcome_message: typing.Optional[str] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        template_variables: typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]] = OMIT,
        tools: typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]] = OMIT,
        tasks: typing.Optional[typing.Sequence[Task]] = OMIT,
        no_input_poke_sec: typing.Optional[int] = OMIT,
        no_input_poke_text: typing.Optional[str] = OMIT,
        no_input_end_conversation_sec: typing.Optional[int] = OMIT,
        boosted_keywords: typing.Optional[typing.Sequence[str]] = OMIT,
        configuration_endpoint: typing.Optional[CreateAgentRequestConfigurationEndpoint] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PutAgentsUpsertResponse]:
        """
        Upserts an agent by name. If an agent with the same name already exists, it will be updated. Otherwise, it will be created.

        Parameters
        ----------
        name : str
            The name of the agent. Can only contain lowercase letters, numbers and hyphens. Must be unique within the project.

        project : typing.Optional[str]
            The name of the project containing the agent.

        phone_number : typing.Optional[typing.Literal["assign-automatically"]]

        timezone : typing.Optional[str]
            The timezone of the agent. Used to format system variables like `{{system_time}}`.

        voice_id : typing.Optional[str]
            The voice ID to use.

        audio_format : typing.Optional[CreateAgentRequestAudioFormat]
            The audio format of the agent.

        audio_speed : typing.Optional[float]
            The audio speed of the agent.

        welcome_message : typing.Optional[str]
            Message to play when the conversation starts. Can contain template variables like `{{customer_name}}`.

        system_prompt : typing.Optional[str]
            Instructions for the conversation. Can contain template variables like `{{subject}}`.

        template_variables : typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]]
            Variables that can be used in the welcome message and the system prompt.

        tools : typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]]
            Array of built-in or custom tool names to use.

        tasks : typing.Optional[typing.Sequence[Task]]
            Array of task objects with `name` and `description` fields.

        no_input_poke_sec : typing.Optional[int]
            Number of seconds of silence before sending a poke message. `null` disables the poke message.

        no_input_poke_text : typing.Optional[str]
            The message to send after the specified silence.

        no_input_end_conversation_sec : typing.Optional[int]
            Seconds of silence before ending the conversation.

        boosted_keywords : typing.Optional[typing.Sequence[str]]
            These words, or short phrases, will be more accurately recognized by the agent.

        configuration_endpoint : typing.Optional[CreateAgentRequestConfigurationEndpoint]
            When not `null`, at the beginning of the conversation the agent will make a POST request to this endpoint when to get configuration options.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PutAgentsUpsertResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/upsert",
            base_url=self._client_wrapper.get_environment().base,
            method="PUT",
            params={
                "project": project,
            },
            json={
                "name": name,
                "phone_number": phone_number,
                "timezone": timezone,
                "voice_id": voice_id,
                "audio_format": audio_format,
                "audio_speed": audio_speed,
                "welcome_message": welcome_message,
                "system_prompt": system_prompt,
                "template_variables": convert_and_respect_annotation_metadata(
                    object_=template_variables,
                    annotation=typing.Dict[str, CreateAgentRequestTemplateVariablesValue],
                    direction="write",
                ),
                "tools": convert_and_respect_annotation_metadata(
                    object_=tools, annotation=typing.Sequence[CreateAgentRequestToolsItem], direction="write"
                ),
                "tasks": convert_and_respect_annotation_metadata(
                    object_=tasks, annotation=typing.Sequence[Task], direction="write"
                ),
                "no_input_poke_sec": no_input_poke_sec,
                "no_input_poke_text": no_input_poke_text,
                "no_input_end_conversation_sec": no_input_end_conversation_sec,
                "boosted_keywords": boosted_keywords,
                "configuration_endpoint": convert_and_respect_annotation_metadata(
                    object_=configuration_endpoint,
                    annotation=CreateAgentRequestConfigurationEndpoint,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PutAgentsUpsertResponse,
                    parse_obj_as(
                        type_=PutAgentsUpsertResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_agents_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetAgentsNameOrIdResponse]:
        """
        Returns an agent by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the agent to get.

        project : typing.Optional[str]
            The name of the project containing the agent. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAgentsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAgentsNameOrIdResponse,
                    parse_obj_as(
                        type_=GetAgentsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_agents_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeleteAgentsNameOrIdResponse]:
        """
        Deletes an agent by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the agent to delete.

        project : typing.Optional[str]
            The name of the project containing the agent. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteAgentsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteAgentsNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteAgentsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def patch_agents_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        phone_number: typing.Optional[typing.Literal["assign-automatically"]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[str] = OMIT,
        audio_format: typing.Optional[UpdateAgentRequestAudioFormat] = OMIT,
        audio_speed: typing.Optional[float] = OMIT,
        welcome_message: typing.Optional[str] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        template_variables: typing.Optional[typing.Dict[str, UpdateAgentRequestTemplateVariablesValue]] = OMIT,
        tools: typing.Optional[typing.Sequence[UpdateAgentRequestToolsItem]] = OMIT,
        tasks: typing.Optional[typing.Sequence[Task]] = OMIT,
        no_input_poke_sec: typing.Optional[int] = OMIT,
        no_input_poke_text: typing.Optional[str] = OMIT,
        no_input_end_conversation_sec: typing.Optional[int] = OMIT,
        boosted_keywords: typing.Optional[typing.Sequence[str]] = OMIT,
        configuration_endpoint: typing.Optional[UpdateAgentRequestConfigurationEndpoint] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PatchAgentsNameOrIdResponse]:
        """
        Updates an agent by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the agent to update.

        project : typing.Optional[str]
            The name of the project containing the agent. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            The name of the agent. Can only contain lowercase letters, numbers and hyphens. Must be unique within the project.

        phone_number : typing.Optional[typing.Literal["assign-automatically"]]

        timezone : typing.Optional[str]
            The timezone of the agent. Used to format system variables like `{{system_time}}`.

        voice_id : typing.Optional[str]
            The voice ID to use.

        audio_format : typing.Optional[UpdateAgentRequestAudioFormat]
            The audio format of the agent.

        audio_speed : typing.Optional[float]
            The audio speed of the agent.

        welcome_message : typing.Optional[str]
            Message to play when the conversation starts. Can contain template variables like `{{customer_name}}`.

        system_prompt : typing.Optional[str]
            Instructions for the conversation. Can contain template variables like `{{subject}}`.

        template_variables : typing.Optional[typing.Dict[str, UpdateAgentRequestTemplateVariablesValue]]
            Variables that can be used in the welcome message and the system prompt.

        tools : typing.Optional[typing.Sequence[UpdateAgentRequestToolsItem]]
            Array of built-in or custom tool names to use.

        tasks : typing.Optional[typing.Sequence[Task]]
            Array of task objects with `name` and `description` fields.

        no_input_poke_sec : typing.Optional[int]
            Number of seconds of silence before sending a poke message. `null` disables the poke message.

        no_input_poke_text : typing.Optional[str]
            The message to send after the specified silence.

        no_input_end_conversation_sec : typing.Optional[int]
            Seconds of silence before ending the conversation.

        boosted_keywords : typing.Optional[typing.Sequence[str]]
            These words, or short phrases, will be more accurately recognized by the agent.

        configuration_endpoint : typing.Optional[UpdateAgentRequestConfigurationEndpoint]
            When not `null`, at the beginning of the conversation the agent will make a POST request to this endpoint when to get configuration options.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PatchAgentsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "phone_number": phone_number,
                "timezone": timezone,
                "voice_id": voice_id,
                "audio_format": audio_format,
                "audio_speed": audio_speed,
                "welcome_message": welcome_message,
                "system_prompt": system_prompt,
                "template_variables": convert_and_respect_annotation_metadata(
                    object_=template_variables,
                    annotation=typing.Dict[str, UpdateAgentRequestTemplateVariablesValue],
                    direction="write",
                ),
                "tools": convert_and_respect_annotation_metadata(
                    object_=tools, annotation=typing.Sequence[UpdateAgentRequestToolsItem], direction="write"
                ),
                "tasks": convert_and_respect_annotation_metadata(
                    object_=tasks, annotation=typing.Sequence[Task], direction="write"
                ),
                "no_input_poke_sec": no_input_poke_sec,
                "no_input_poke_text": no_input_poke_text,
                "no_input_end_conversation_sec": no_input_end_conversation_sec,
                "boosted_keywords": boosted_keywords,
                "configuration_endpoint": convert_and_respect_annotation_metadata(
                    object_=configuration_endpoint,
                    annotation=UpdateAgentRequestConfigurationEndpoint,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchAgentsNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchAgentsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_tools(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetToolsResponse]:
        """
        Returns all custom tools for the organization.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list tools for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetToolsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetToolsResponse,
                    parse_obj_as(
                        type_=GetToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_tools(
        self,
        *,
        name: str,
        description: str,
        type: CreateToolRequestType,
        execution_mode: CreateToolRequestExecutionMode,
        project: typing.Optional[str] = None,
        parameters: typing.Optional[typing.Sequence[ToolParameter]] = OMIT,
        endpoint_method: typing.Optional[typing.Literal["POST"]] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostToolsResponse]:
        """
        Creates a new tool in a project.

        Parameters
        ----------
        name : str
            The name of the tool. Must be snake_case and unique within the organization.

        description : str
            A description of what the tool does.

        type : CreateToolRequestType
            The type of tool.

        execution_mode : CreateToolRequestExecutionMode
            Mode of operation.

        project : typing.Optional[str]
            The name of the project to create the tool in.

        parameters : typing.Optional[typing.Sequence[ToolParameter]]
            Array of parameter definitions.

        endpoint_method : typing.Optional[typing.Literal["POST"]]
            Required for webhook tools.

        endpoint_url : typing.Optional[str]
            Required for webhook tools.

        endpoint_headers : typing.Optional[typing.Dict[str, str]]
            Optional headers for webhook tools.

        endpoint_timeout_ms : typing.Optional[int]
            Timeout for webhook tools.

        tool_call_output_timeout_ms : typing.Optional[int]
            Timeout for WebSocket tool responses.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostToolsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameter], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostToolsResponse,
                    parse_obj_as(
                        type_=PostToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_tools_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetToolsNameOrIdResponse]:
        """
        Returns a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to get.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetToolsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetToolsNameOrIdResponse,
                    parse_obj_as(
                        type_=GetToolsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_tools_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeleteToolsNameOrIdResponse]:
        """
        Deletes a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to delete.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteToolsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteToolsNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteToolsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def patch_tools_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        type: typing.Optional[UpdateToolRequestType] = OMIT,
        execution_mode: typing.Optional[UpdateToolRequestExecutionMode] = OMIT,
        parameters: typing.Optional[typing.Sequence[ToolParameter]] = OMIT,
        endpoint_method: typing.Optional[typing.Literal["POST"]] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PatchToolsNameOrIdResponse]:
        """
        Updates a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to update.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            The name of the tool. Must be snake_case and unique within the organization.

        description : typing.Optional[str]
            A description of what the tool does.

        type : typing.Optional[UpdateToolRequestType]
            The type of tool.

        execution_mode : typing.Optional[UpdateToolRequestExecutionMode]
            Mode of operation.

        parameters : typing.Optional[typing.Sequence[ToolParameter]]
            Array of parameter definitions.

        endpoint_method : typing.Optional[typing.Literal["POST"]]

        endpoint_url : typing.Optional[str]

        endpoint_headers : typing.Optional[typing.Dict[str, str]]

        endpoint_timeout_ms : typing.Optional[int]

        tool_call_output_timeout_ms : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PatchToolsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameter], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchToolsNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchToolsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_extraction_schemas(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetExtractionSchemasResponse]:
        """
        Returns all extraction schemas in a project.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list extraction schemas for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetExtractionSchemasResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "extraction_schemas",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetExtractionSchemasResponse,
                    parse_obj_as(
                        type_=GetExtractionSchemasResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_extraction_schemas(
        self,
        *,
        name: str,
        prompt: str,
        fields: typing.Sequence[ExtractionField],
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostExtractionSchemasResponse]:
        """
        Creates a new extraction schema in a project.

        Parameters
        ----------
        name : str
            A name for the extraction schema.

        prompt : str
            Instructions for how to extract data from conversations.

        fields : typing.Sequence[ExtractionField]
            Array of field definitions.

        project : typing.Optional[str]
            The name of the project to create the extraction schema in.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostExtractionSchemasResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "extraction_schemas",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "prompt": prompt,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ExtractionField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostExtractionSchemasResponse,
                    parse_obj_as(
                        type_=PostExtractionSchemasResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_extraction_schemas_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetExtractionSchemasNameOrIdResponse]:
        """
        Returns an extraction schema by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the extraction schema to get.

        project : typing.Optional[str]
            The name of the project containing the extraction schema. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetExtractionSchemasNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"extraction_schemas/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetExtractionSchemasNameOrIdResponse,
                    parse_obj_as(
                        type_=GetExtractionSchemasNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_extraction_schemas_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeleteExtractionSchemasNameOrIdResponse]:
        """
        Deletes an extraction schema by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the extraction schema to delete.

        project : typing.Optional[str]
            The name of the project containing the extraction schema. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteExtractionSchemasNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"extraction_schemas/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteExtractionSchemasNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteExtractionSchemasNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def patch_extraction_schemas_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        prompt: typing.Optional[str] = OMIT,
        fields: typing.Optional[typing.Sequence[ExtractionField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PatchExtractionSchemasNameOrIdResponse]:
        """
        Updates an extraction schema by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the extraction schema to update.

        project : typing.Optional[str]
            The name of the project containing the extraction schema. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            A name for the extraction schema.

        prompt : typing.Optional[str]
            Instructions for how to extract data from conversations.

        fields : typing.Optional[typing.Sequence[ExtractionField]]
            Array of field definitions.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PatchExtractionSchemasNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"extraction_schemas/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "prompt": prompt,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ExtractionField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchExtractionSchemasNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchExtractionSchemasNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_voices(self, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[GetVoicesResponse]:
        """
        Returns all available voices for a model.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetVoicesResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "voices",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "model": "merritt",
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetVoicesResponse,
                    parse_obj_as(
                        type_=GetVoicesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_voices_id(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetVoicesIdResponse]:
        """
        Returns a voice by ID.

        Parameters
        ----------
        id : str
            The ID of the voice to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetVoicesIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"voices/{jsonable_encoder(id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetVoicesIdResponse,
                    parse_obj_as(
                        type_=GetVoicesIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_conversations(
        self,
        *,
        project: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        duration_min: typing.Optional[int] = None,
        duration_max: typing.Optional[int] = None,
        started_at_min: typing.Optional[str] = None,
        started_at_max: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetConversationsResponse]:
        """
        Returns conversations with optional filtering.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list conversations for.

        external_id : typing.Optional[str]
            Filter by external ID to get a specific conversation.

        duration_min : typing.Optional[int]
            Minimum duration in seconds.

        duration_max : typing.Optional[int]
            Maximum duration in seconds.

        started_at_min : typing.Optional[str]
            Minimum start date/time. Valid examples: `2025-04-17`, `2025-04-17T02:48:52.708Z`

        started_at_max : typing.Optional[str]
            Maximum start date/time. Valid examples: `2025-04-17`, `2025-04-17T02:48:52.708Z`

        before : typing.Optional[str]
            Cursor for pagination (before).

        after : typing.Optional[str]
            Cursor for pagination (after).

        limit : typing.Optional[int]
            Maximum number of conversations to return.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "conversations",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
                "external_id": external_id,
                "duration_min": duration_min,
                "duration_max": duration_max,
                "started_at_min": started_at_min,
                "started_at_max": started_at_max,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsResponse,
                    parse_obj_as(
                        type_=GetConversationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_conversations_id(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetConversationsIdResponse]:
        """
        Returns a conversation by ID.

        Parameters
        ----------
        id : str
            The ID of the conversation to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationsIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdResponse,
                    parse_obj_as(
                        type_=GetConversationsIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_conversations_id_cancel(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PostConversationsIdCancelResponse]:
        """
        Cancels an active conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to cancel.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostConversationsIdCancelResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/cancel",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsIdCancelResponse,
                    parse_obj_as(
                        type_=PostConversationsIdCancelResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 504:
                raise GatewayTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_conversations_id_analysis(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetConversationsIdAnalysisResponse]:
        """
        Returns an analysis of the specified conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to analyze.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationsIdAnalysisResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/analysis",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdAnalysisResponse,
                    parse_obj_as(
                        type_=GetConversationsIdAnalysisResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_conversations_id_extractions(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetConversationsIdExtractionsResponse]:
        """
        Returns all extractions for a conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to get extractions for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationsIdExtractionsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/extractions",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdExtractionsResponse,
                    parse_obj_as(
                        type_=GetConversationsIdExtractionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_conversations_id_extractions(
        self, id: str, *, schema_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PostConversationsIdExtractionsResponse]:
        """
        Extracts data from a conversation using a schema.

        Parameters
        ----------
        id : str
            The ID of the conversation to extract data from.

        schema_id : str
            ID of the extraction schema to use.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostConversationsIdExtractionsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/extractions",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "schema_id": schema_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsIdExtractionsResponse,
                    parse_obj_as(
                        type_=PostConversationsIdExtractionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_conversations_id_evals(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetConversationsIdEvalsResponse]:
        """
        Returns all evaluations for a conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to get evaluations for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationsIdEvalsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/evals",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdEvalsResponse,
                    parse_obj_as(
                        type_=GetConversationsIdEvalsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_conversations_id_evals(
        self, id: str, *, prompt_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ConversationEvaluationResult]:
        """
        Evaluates a conversation using an evaluation prompt.

        Parameters
        ----------
        id : str
            The ID of the conversation to evaluate.

        prompt_id : str
            ID of the evaluation prompt to use.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ConversationEvaluationResult]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/evals",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "prompt_id": prompt_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConversationEvaluationResult,
                    parse_obj_as(
                        type_=ConversationEvaluationResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_conversations_outbound_call(
        self,
        *,
        to_phone_number: str,
        config: typing.Optional[OutboundCallConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostConversationsOutboundCallResponse]:
        """
        Initiates a call to a given phone number using Phonic's Twilio account.

        Parameters
        ----------
        to_phone_number : str
            The phone number to call in E.164 format.

        config : typing.Optional[OutboundCallConfig]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostConversationsOutboundCallResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "conversations/outbound_call",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "to_phone_number": to_phone_number,
                "config": convert_and_respect_annotation_metadata(
                    object_=config, annotation=OutboundCallConfig, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsOutboundCallResponse,
                    parse_obj_as(
                        type_=PostConversationsOutboundCallResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_conversations_sip_outbound_call(
        self,
        *,
        sip_address: str,
        from_phone_number: str,
        to_phone_number: str,
        token: typing.Optional[str] = None,
        downstream_websocket_url: typing.Optional[str] = None,
        sip_auth_username: typing.Optional[str] = None,
        sip_auth_password: typing.Optional[str] = None,
        config: typing.Optional[OutboundCallConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostConversationsSipOutboundCallResponse]:
        """
        Initiates a SIP outbound call using user-supplied SIP credentials in headers.

        Parameters
        ----------
        sip_address : str
            SIP address of the user's SIP trunk. Required.

        from_phone_number : str
            Caller ID phone number in E.164 format.

        to_phone_number : str
            Destination phone number in E.164 format.

        token : typing.Optional[str]
            Optional session token used for STS authorization.

        downstream_websocket_url : typing.Optional[str]
            Optional downstream STS WebSocket URL to override the default.

        sip_auth_username : typing.Optional[str]
            SIP auth username, if your provider requires it.

        sip_auth_password : typing.Optional[str]
            SIP auth password, if your provider requires it.

        config : typing.Optional[OutboundCallConfig]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostConversationsSipOutboundCallResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "conversations/sip/outbound_call",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "token": token,
                "downstream_websocket_url": downstream_websocket_url,
            },
            json={
                "from_phone_number": from_phone_number,
                "to_phone_number": to_phone_number,
                "config": convert_and_respect_annotation_metadata(
                    object_=config, annotation=OutboundCallConfig, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "X-Sip-Address": str(sip_address) if sip_address is not None else None,
                "X-Sip-Auth-Username": str(sip_auth_username) if sip_auth_username is not None else None,
                "X-Sip-Auth-Password": str(sip_auth_password) if sip_auth_password is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsSipOutboundCallResponse,
                    parse_obj_as(
                        type_=PostConversationsSipOutboundCallResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_projects(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetProjectsResponse]:
        """
        Returns all projects in a workspace.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetProjectsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "projects",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProjectsResponse,
                    parse_obj_as(
                        type_=GetProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_projects(
        self, *, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PostProjectsResponse]:
        """
        Creates a new project in a workspace.

        Parameters
        ----------
        name : str
            The name of the project. Can only contain lowercase letters, numbers and hyphens. Must be unique within the workspace.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostProjectsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "projects",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostProjectsResponse,
                    parse_obj_as(
                        type_=PostProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_projects_name_or_id(
        self, name_or_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetProjectsNameOrIdResponse]:
        """
        Returns a project by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the project to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetProjectsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProjectsNameOrIdResponse,
                    parse_obj_as(
                        type_=GetProjectsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_projects_name_or_id(
        self, name_or_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteProjectsNameOrIdResponse]:
        """
        Deletes a project by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the project to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteProjectsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteProjectsNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteProjectsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def patch_projects_name_or_id(
        self,
        name_or_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        default_agent: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PatchProjectsNameOrIdResponse]:
        """
        Updates a project by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the project to update.

        name : typing.Optional[str]
            The name of the project. Can only contain lowercase letters, numbers and hyphens. Must be unique within the workspace.

        default_agent : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PatchProjectsNameOrIdResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            json={
                "name": name,
                "default_agent": default_agent,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchProjectsNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchProjectsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_projects_id_conversation_eval_prompts(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetProjectsIdConversationEvalPromptsResponse]:
        """
        Returns all conversation evaluation prompts for a project.

        Parameters
        ----------
        id : str
            The ID of the project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetProjectsIdConversationEvalPromptsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(id)}/conversation_eval_prompts",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProjectsIdConversationEvalPromptsResponse,
                    parse_obj_as(
                        type_=GetProjectsIdConversationEvalPromptsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_projects_id_conversation_eval_prompts(
        self, id: str, *, name: str, prompt: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PostProjectsIdConversationEvalPromptsResponse]:
        """
        Creates a new conversation evaluation prompt for a project.

        Parameters
        ----------
        id : str
            The ID of the project.

        name : str
            A useful name for referring to this prompt.

        prompt : str
            Actual evaluation prompt text to evaluate conversations with.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostProjectsIdConversationEvalPromptsResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(id)}/conversation_eval_prompts",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "name": name,
                "prompt": prompt,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostProjectsIdConversationEvalPromptsResponse,
                    parse_obj_as(
                        type_=PostProjectsIdConversationEvalPromptsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawPhonic:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_agents(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAgentsResponse]:
        """
        Returns all agents in a project.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list agents for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAgentsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAgentsResponse,
                    parse_obj_as(
                        type_=GetAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_agents(
        self,
        *,
        name: str,
        project: typing.Optional[str] = None,
        phone_number: typing.Optional[typing.Literal["assign-automatically"]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[str] = OMIT,
        audio_format: typing.Optional[CreateAgentRequestAudioFormat] = OMIT,
        audio_speed: typing.Optional[float] = OMIT,
        welcome_message: typing.Optional[str] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        template_variables: typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]] = OMIT,
        tools: typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]] = OMIT,
        tasks: typing.Optional[typing.Sequence[Task]] = OMIT,
        no_input_poke_sec: typing.Optional[int] = OMIT,
        no_input_poke_text: typing.Optional[str] = OMIT,
        no_input_end_conversation_sec: typing.Optional[int] = OMIT,
        boosted_keywords: typing.Optional[typing.Sequence[str]] = OMIT,
        configuration_endpoint: typing.Optional[CreateAgentRequestConfigurationEndpoint] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostAgentsResponse]:
        """
        Creates a new agent in a project.

        Parameters
        ----------
        name : str
            The name of the agent. Can only contain lowercase letters, numbers and hyphens. Must be unique within the project.

        project : typing.Optional[str]
            The name of the project to create the agent in.

        phone_number : typing.Optional[typing.Literal["assign-automatically"]]

        timezone : typing.Optional[str]
            The timezone of the agent. Used to format system variables like `{{system_time}}`.

        voice_id : typing.Optional[str]
            The voice ID to use.

        audio_format : typing.Optional[CreateAgentRequestAudioFormat]
            The audio format of the agent.

        audio_speed : typing.Optional[float]
            The audio speed of the agent.

        welcome_message : typing.Optional[str]
            Message to play when the conversation starts. Can contain template variables like `{{customer_name}}`.

        system_prompt : typing.Optional[str]
            Instructions for the conversation. Can contain template variables like `{{subject}}`.

        template_variables : typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]]
            Variables that can be used in the welcome message and the system prompt.

        tools : typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]]
            Array of built-in or custom tool names to use.

        tasks : typing.Optional[typing.Sequence[Task]]
            Array of task objects with `name` and `description` fields.

        no_input_poke_sec : typing.Optional[int]
            Number of seconds of silence before sending a poke message. `null` disables the poke message.

        no_input_poke_text : typing.Optional[str]
            The message to send after the specified silence.

        no_input_end_conversation_sec : typing.Optional[int]
            Seconds of silence before ending the conversation.

        boosted_keywords : typing.Optional[typing.Sequence[str]]
            These words, or short phrases, will be more accurately recognized by the agent.

        configuration_endpoint : typing.Optional[CreateAgentRequestConfigurationEndpoint]
            When not `null`, at the beginning of the conversation the agent will make a POST request to this endpoint when to get configuration options.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostAgentsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "phone_number": phone_number,
                "timezone": timezone,
                "voice_id": voice_id,
                "audio_format": audio_format,
                "audio_speed": audio_speed,
                "welcome_message": welcome_message,
                "system_prompt": system_prompt,
                "template_variables": convert_and_respect_annotation_metadata(
                    object_=template_variables,
                    annotation=typing.Dict[str, CreateAgentRequestTemplateVariablesValue],
                    direction="write",
                ),
                "tools": convert_and_respect_annotation_metadata(
                    object_=tools, annotation=typing.Sequence[CreateAgentRequestToolsItem], direction="write"
                ),
                "tasks": convert_and_respect_annotation_metadata(
                    object_=tasks, annotation=typing.Sequence[Task], direction="write"
                ),
                "no_input_poke_sec": no_input_poke_sec,
                "no_input_poke_text": no_input_poke_text,
                "no_input_end_conversation_sec": no_input_end_conversation_sec,
                "boosted_keywords": boosted_keywords,
                "configuration_endpoint": convert_and_respect_annotation_metadata(
                    object_=configuration_endpoint,
                    annotation=CreateAgentRequestConfigurationEndpoint,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostAgentsResponse,
                    parse_obj_as(
                        type_=PostAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def put_agents_upsert(
        self,
        *,
        name: str,
        project: typing.Optional[str] = None,
        phone_number: typing.Optional[typing.Literal["assign-automatically"]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[str] = OMIT,
        audio_format: typing.Optional[CreateAgentRequestAudioFormat] = OMIT,
        audio_speed: typing.Optional[float] = OMIT,
        welcome_message: typing.Optional[str] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        template_variables: typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]] = OMIT,
        tools: typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]] = OMIT,
        tasks: typing.Optional[typing.Sequence[Task]] = OMIT,
        no_input_poke_sec: typing.Optional[int] = OMIT,
        no_input_poke_text: typing.Optional[str] = OMIT,
        no_input_end_conversation_sec: typing.Optional[int] = OMIT,
        boosted_keywords: typing.Optional[typing.Sequence[str]] = OMIT,
        configuration_endpoint: typing.Optional[CreateAgentRequestConfigurationEndpoint] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PutAgentsUpsertResponse]:
        """
        Upserts an agent by name. If an agent with the same name already exists, it will be updated. Otherwise, it will be created.

        Parameters
        ----------
        name : str
            The name of the agent. Can only contain lowercase letters, numbers and hyphens. Must be unique within the project.

        project : typing.Optional[str]
            The name of the project containing the agent.

        phone_number : typing.Optional[typing.Literal["assign-automatically"]]

        timezone : typing.Optional[str]
            The timezone of the agent. Used to format system variables like `{{system_time}}`.

        voice_id : typing.Optional[str]
            The voice ID to use.

        audio_format : typing.Optional[CreateAgentRequestAudioFormat]
            The audio format of the agent.

        audio_speed : typing.Optional[float]
            The audio speed of the agent.

        welcome_message : typing.Optional[str]
            Message to play when the conversation starts. Can contain template variables like `{{customer_name}}`.

        system_prompt : typing.Optional[str]
            Instructions for the conversation. Can contain template variables like `{{subject}}`.

        template_variables : typing.Optional[typing.Dict[str, CreateAgentRequestTemplateVariablesValue]]
            Variables that can be used in the welcome message and the system prompt.

        tools : typing.Optional[typing.Sequence[CreateAgentRequestToolsItem]]
            Array of built-in or custom tool names to use.

        tasks : typing.Optional[typing.Sequence[Task]]
            Array of task objects with `name` and `description` fields.

        no_input_poke_sec : typing.Optional[int]
            Number of seconds of silence before sending a poke message. `null` disables the poke message.

        no_input_poke_text : typing.Optional[str]
            The message to send after the specified silence.

        no_input_end_conversation_sec : typing.Optional[int]
            Seconds of silence before ending the conversation.

        boosted_keywords : typing.Optional[typing.Sequence[str]]
            These words, or short phrases, will be more accurately recognized by the agent.

        configuration_endpoint : typing.Optional[CreateAgentRequestConfigurationEndpoint]
            When not `null`, at the beginning of the conversation the agent will make a POST request to this endpoint when to get configuration options.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PutAgentsUpsertResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/upsert",
            base_url=self._client_wrapper.get_environment().base,
            method="PUT",
            params={
                "project": project,
            },
            json={
                "name": name,
                "phone_number": phone_number,
                "timezone": timezone,
                "voice_id": voice_id,
                "audio_format": audio_format,
                "audio_speed": audio_speed,
                "welcome_message": welcome_message,
                "system_prompt": system_prompt,
                "template_variables": convert_and_respect_annotation_metadata(
                    object_=template_variables,
                    annotation=typing.Dict[str, CreateAgentRequestTemplateVariablesValue],
                    direction="write",
                ),
                "tools": convert_and_respect_annotation_metadata(
                    object_=tools, annotation=typing.Sequence[CreateAgentRequestToolsItem], direction="write"
                ),
                "tasks": convert_and_respect_annotation_metadata(
                    object_=tasks, annotation=typing.Sequence[Task], direction="write"
                ),
                "no_input_poke_sec": no_input_poke_sec,
                "no_input_poke_text": no_input_poke_text,
                "no_input_end_conversation_sec": no_input_end_conversation_sec,
                "boosted_keywords": boosted_keywords,
                "configuration_endpoint": convert_and_respect_annotation_metadata(
                    object_=configuration_endpoint,
                    annotation=CreateAgentRequestConfigurationEndpoint,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PutAgentsUpsertResponse,
                    parse_obj_as(
                        type_=PutAgentsUpsertResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_agents_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetAgentsNameOrIdResponse]:
        """
        Returns an agent by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the agent to get.

        project : typing.Optional[str]
            The name of the project containing the agent. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAgentsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAgentsNameOrIdResponse,
                    parse_obj_as(
                        type_=GetAgentsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_agents_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeleteAgentsNameOrIdResponse]:
        """
        Deletes an agent by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the agent to delete.

        project : typing.Optional[str]
            The name of the project containing the agent. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteAgentsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteAgentsNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteAgentsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def patch_agents_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        phone_number: typing.Optional[typing.Literal["assign-automatically"]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[str] = OMIT,
        audio_format: typing.Optional[UpdateAgentRequestAudioFormat] = OMIT,
        audio_speed: typing.Optional[float] = OMIT,
        welcome_message: typing.Optional[str] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        template_variables: typing.Optional[typing.Dict[str, UpdateAgentRequestTemplateVariablesValue]] = OMIT,
        tools: typing.Optional[typing.Sequence[UpdateAgentRequestToolsItem]] = OMIT,
        tasks: typing.Optional[typing.Sequence[Task]] = OMIT,
        no_input_poke_sec: typing.Optional[int] = OMIT,
        no_input_poke_text: typing.Optional[str] = OMIT,
        no_input_end_conversation_sec: typing.Optional[int] = OMIT,
        boosted_keywords: typing.Optional[typing.Sequence[str]] = OMIT,
        configuration_endpoint: typing.Optional[UpdateAgentRequestConfigurationEndpoint] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PatchAgentsNameOrIdResponse]:
        """
        Updates an agent by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the agent to update.

        project : typing.Optional[str]
            The name of the project containing the agent. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            The name of the agent. Can only contain lowercase letters, numbers and hyphens. Must be unique within the project.

        phone_number : typing.Optional[typing.Literal["assign-automatically"]]

        timezone : typing.Optional[str]
            The timezone of the agent. Used to format system variables like `{{system_time}}`.

        voice_id : typing.Optional[str]
            The voice ID to use.

        audio_format : typing.Optional[UpdateAgentRequestAudioFormat]
            The audio format of the agent.

        audio_speed : typing.Optional[float]
            The audio speed of the agent.

        welcome_message : typing.Optional[str]
            Message to play when the conversation starts. Can contain template variables like `{{customer_name}}`.

        system_prompt : typing.Optional[str]
            Instructions for the conversation. Can contain template variables like `{{subject}}`.

        template_variables : typing.Optional[typing.Dict[str, UpdateAgentRequestTemplateVariablesValue]]
            Variables that can be used in the welcome message and the system prompt.

        tools : typing.Optional[typing.Sequence[UpdateAgentRequestToolsItem]]
            Array of built-in or custom tool names to use.

        tasks : typing.Optional[typing.Sequence[Task]]
            Array of task objects with `name` and `description` fields.

        no_input_poke_sec : typing.Optional[int]
            Number of seconds of silence before sending a poke message. `null` disables the poke message.

        no_input_poke_text : typing.Optional[str]
            The message to send after the specified silence.

        no_input_end_conversation_sec : typing.Optional[int]
            Seconds of silence before ending the conversation.

        boosted_keywords : typing.Optional[typing.Sequence[str]]
            These words, or short phrases, will be more accurately recognized by the agent.

        configuration_endpoint : typing.Optional[UpdateAgentRequestConfigurationEndpoint]
            When not `null`, at the beginning of the conversation the agent will make a POST request to this endpoint when to get configuration options.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PatchAgentsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "phone_number": phone_number,
                "timezone": timezone,
                "voice_id": voice_id,
                "audio_format": audio_format,
                "audio_speed": audio_speed,
                "welcome_message": welcome_message,
                "system_prompt": system_prompt,
                "template_variables": convert_and_respect_annotation_metadata(
                    object_=template_variables,
                    annotation=typing.Dict[str, UpdateAgentRequestTemplateVariablesValue],
                    direction="write",
                ),
                "tools": convert_and_respect_annotation_metadata(
                    object_=tools, annotation=typing.Sequence[UpdateAgentRequestToolsItem], direction="write"
                ),
                "tasks": convert_and_respect_annotation_metadata(
                    object_=tasks, annotation=typing.Sequence[Task], direction="write"
                ),
                "no_input_poke_sec": no_input_poke_sec,
                "no_input_poke_text": no_input_poke_text,
                "no_input_end_conversation_sec": no_input_end_conversation_sec,
                "boosted_keywords": boosted_keywords,
                "configuration_endpoint": convert_and_respect_annotation_metadata(
                    object_=configuration_endpoint,
                    annotation=UpdateAgentRequestConfigurationEndpoint,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchAgentsNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchAgentsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_tools(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetToolsResponse]:
        """
        Returns all custom tools for the organization.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list tools for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetToolsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetToolsResponse,
                    parse_obj_as(
                        type_=GetToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_tools(
        self,
        *,
        name: str,
        description: str,
        type: CreateToolRequestType,
        execution_mode: CreateToolRequestExecutionMode,
        project: typing.Optional[str] = None,
        parameters: typing.Optional[typing.Sequence[ToolParameter]] = OMIT,
        endpoint_method: typing.Optional[typing.Literal["POST"]] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostToolsResponse]:
        """
        Creates a new tool in a project.

        Parameters
        ----------
        name : str
            The name of the tool. Must be snake_case and unique within the organization.

        description : str
            A description of what the tool does.

        type : CreateToolRequestType
            The type of tool.

        execution_mode : CreateToolRequestExecutionMode
            Mode of operation.

        project : typing.Optional[str]
            The name of the project to create the tool in.

        parameters : typing.Optional[typing.Sequence[ToolParameter]]
            Array of parameter definitions.

        endpoint_method : typing.Optional[typing.Literal["POST"]]
            Required for webhook tools.

        endpoint_url : typing.Optional[str]
            Required for webhook tools.

        endpoint_headers : typing.Optional[typing.Dict[str, str]]
            Optional headers for webhook tools.

        endpoint_timeout_ms : typing.Optional[int]
            Timeout for webhook tools.

        tool_call_output_timeout_ms : typing.Optional[int]
            Timeout for WebSocket tool responses.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostToolsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameter], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostToolsResponse,
                    parse_obj_as(
                        type_=PostToolsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_tools_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetToolsNameOrIdResponse]:
        """
        Returns a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to get.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetToolsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetToolsNameOrIdResponse,
                    parse_obj_as(
                        type_=GetToolsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_tools_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeleteToolsNameOrIdResponse]:
        """
        Deletes a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to delete.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteToolsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteToolsNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteToolsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def patch_tools_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        type: typing.Optional[UpdateToolRequestType] = OMIT,
        execution_mode: typing.Optional[UpdateToolRequestExecutionMode] = OMIT,
        parameters: typing.Optional[typing.Sequence[ToolParameter]] = OMIT,
        endpoint_method: typing.Optional[typing.Literal["POST"]] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PatchToolsNameOrIdResponse]:
        """
        Updates a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to update.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            The name of the tool. Must be snake_case and unique within the organization.

        description : typing.Optional[str]
            A description of what the tool does.

        type : typing.Optional[UpdateToolRequestType]
            The type of tool.

        execution_mode : typing.Optional[UpdateToolRequestExecutionMode]
            Mode of operation.

        parameters : typing.Optional[typing.Sequence[ToolParameter]]
            Array of parameter definitions.

        endpoint_method : typing.Optional[typing.Literal["POST"]]

        endpoint_url : typing.Optional[str]

        endpoint_headers : typing.Optional[typing.Dict[str, str]]

        endpoint_timeout_ms : typing.Optional[int]

        tool_call_output_timeout_ms : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PatchToolsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameter], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchToolsNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchToolsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_extraction_schemas(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetExtractionSchemasResponse]:
        """
        Returns all extraction schemas in a project.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list extraction schemas for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetExtractionSchemasResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "extraction_schemas",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetExtractionSchemasResponse,
                    parse_obj_as(
                        type_=GetExtractionSchemasResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_extraction_schemas(
        self,
        *,
        name: str,
        prompt: str,
        fields: typing.Sequence[ExtractionField],
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostExtractionSchemasResponse]:
        """
        Creates a new extraction schema in a project.

        Parameters
        ----------
        name : str
            A name for the extraction schema.

        prompt : str
            Instructions for how to extract data from conversations.

        fields : typing.Sequence[ExtractionField]
            Array of field definitions.

        project : typing.Optional[str]
            The name of the project to create the extraction schema in.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostExtractionSchemasResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "extraction_schemas",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "prompt": prompt,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ExtractionField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostExtractionSchemasResponse,
                    parse_obj_as(
                        type_=PostExtractionSchemasResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_extraction_schemas_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetExtractionSchemasNameOrIdResponse]:
        """
        Returns an extraction schema by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the extraction schema to get.

        project : typing.Optional[str]
            The name of the project containing the extraction schema. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetExtractionSchemasNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"extraction_schemas/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetExtractionSchemasNameOrIdResponse,
                    parse_obj_as(
                        type_=GetExtractionSchemasNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_extraction_schemas_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeleteExtractionSchemasNameOrIdResponse]:
        """
        Deletes an extraction schema by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the extraction schema to delete.

        project : typing.Optional[str]
            The name of the project containing the extraction schema. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteExtractionSchemasNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"extraction_schemas/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteExtractionSchemasNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteExtractionSchemasNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def patch_extraction_schemas_name_or_id(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        prompt: typing.Optional[str] = OMIT,
        fields: typing.Optional[typing.Sequence[ExtractionField]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PatchExtractionSchemasNameOrIdResponse]:
        """
        Updates an extraction schema by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the extraction schema to update.

        project : typing.Optional[str]
            The name of the project containing the extraction schema. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            A name for the extraction schema.

        prompt : typing.Optional[str]
            Instructions for how to extract data from conversations.

        fields : typing.Optional[typing.Sequence[ExtractionField]]
            Array of field definitions.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PatchExtractionSchemasNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"extraction_schemas/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "prompt": prompt,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ExtractionField], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchExtractionSchemasNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchExtractionSchemasNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_voices(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetVoicesResponse]:
        """
        Returns all available voices for a model.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetVoicesResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "voices",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "model": "merritt",
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetVoicesResponse,
                    parse_obj_as(
                        type_=GetVoicesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_voices_id(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetVoicesIdResponse]:
        """
        Returns a voice by ID.

        Parameters
        ----------
        id : str
            The ID of the voice to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetVoicesIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"voices/{jsonable_encoder(id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetVoicesIdResponse,
                    parse_obj_as(
                        type_=GetVoicesIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_conversations(
        self,
        *,
        project: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        duration_min: typing.Optional[int] = None,
        duration_max: typing.Optional[int] = None,
        started_at_min: typing.Optional[str] = None,
        started_at_max: typing.Optional[str] = None,
        before: typing.Optional[str] = None,
        after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetConversationsResponse]:
        """
        Returns conversations with optional filtering.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list conversations for.

        external_id : typing.Optional[str]
            Filter by external ID to get a specific conversation.

        duration_min : typing.Optional[int]
            Minimum duration in seconds.

        duration_max : typing.Optional[int]
            Maximum duration in seconds.

        started_at_min : typing.Optional[str]
            Minimum start date/time. Valid examples: `2025-04-17`, `2025-04-17T02:48:52.708Z`

        started_at_max : typing.Optional[str]
            Maximum start date/time. Valid examples: `2025-04-17`, `2025-04-17T02:48:52.708Z`

        before : typing.Optional[str]
            Cursor for pagination (before).

        after : typing.Optional[str]
            Cursor for pagination (after).

        limit : typing.Optional[int]
            Maximum number of conversations to return.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "conversations",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
                "external_id": external_id,
                "duration_min": duration_min,
                "duration_max": duration_max,
                "started_at_min": started_at_min,
                "started_at_max": started_at_max,
                "before": before,
                "after": after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsResponse,
                    parse_obj_as(
                        type_=GetConversationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_conversations_id(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetConversationsIdResponse]:
        """
        Returns a conversation by ID.

        Parameters
        ----------
        id : str
            The ID of the conversation to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationsIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdResponse,
                    parse_obj_as(
                        type_=GetConversationsIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_conversations_id_cancel(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PostConversationsIdCancelResponse]:
        """
        Cancels an active conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to cancel.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostConversationsIdCancelResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/cancel",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsIdCancelResponse,
                    parse_obj_as(
                        type_=PostConversationsIdCancelResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 504:
                raise GatewayTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_conversations_id_analysis(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetConversationsIdAnalysisResponse]:
        """
        Returns an analysis of the specified conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to analyze.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationsIdAnalysisResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/analysis",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdAnalysisResponse,
                    parse_obj_as(
                        type_=GetConversationsIdAnalysisResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_conversations_id_extractions(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetConversationsIdExtractionsResponse]:
        """
        Returns all extractions for a conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to get extractions for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationsIdExtractionsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/extractions",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdExtractionsResponse,
                    parse_obj_as(
                        type_=GetConversationsIdExtractionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_conversations_id_extractions(
        self, id: str, *, schema_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PostConversationsIdExtractionsResponse]:
        """
        Extracts data from a conversation using a schema.

        Parameters
        ----------
        id : str
            The ID of the conversation to extract data from.

        schema_id : str
            ID of the extraction schema to use.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostConversationsIdExtractionsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/extractions",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "schema_id": schema_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsIdExtractionsResponse,
                    parse_obj_as(
                        type_=PostConversationsIdExtractionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_conversations_id_evals(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetConversationsIdEvalsResponse]:
        """
        Returns all evaluations for a conversation.

        Parameters
        ----------
        id : str
            The ID of the conversation to get evaluations for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationsIdEvalsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/evals",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationsIdEvalsResponse,
                    parse_obj_as(
                        type_=GetConversationsIdEvalsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_conversations_id_evals(
        self, id: str, *, prompt_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ConversationEvaluationResult]:
        """
        Evaluates a conversation using an evaluation prompt.

        Parameters
        ----------
        id : str
            The ID of the conversation to evaluate.

        prompt_id : str
            ID of the evaluation prompt to use.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ConversationEvaluationResult]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(id)}/evals",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "prompt_id": prompt_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConversationEvaluationResult,
                    parse_obj_as(
                        type_=ConversationEvaluationResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_conversations_outbound_call(
        self,
        *,
        to_phone_number: str,
        config: typing.Optional[OutboundCallConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostConversationsOutboundCallResponse]:
        """
        Initiates a call to a given phone number using Phonic's Twilio account.

        Parameters
        ----------
        to_phone_number : str
            The phone number to call in E.164 format.

        config : typing.Optional[OutboundCallConfig]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostConversationsOutboundCallResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "conversations/outbound_call",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "to_phone_number": to_phone_number,
                "config": convert_and_respect_annotation_metadata(
                    object_=config, annotation=OutboundCallConfig, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsOutboundCallResponse,
                    parse_obj_as(
                        type_=PostConversationsOutboundCallResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_conversations_sip_outbound_call(
        self,
        *,
        sip_address: str,
        from_phone_number: str,
        to_phone_number: str,
        token: typing.Optional[str] = None,
        downstream_websocket_url: typing.Optional[str] = None,
        sip_auth_username: typing.Optional[str] = None,
        sip_auth_password: typing.Optional[str] = None,
        config: typing.Optional[OutboundCallConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostConversationsSipOutboundCallResponse]:
        """
        Initiates a SIP outbound call using user-supplied SIP credentials in headers.

        Parameters
        ----------
        sip_address : str
            SIP address of the user's SIP trunk. Required.

        from_phone_number : str
            Caller ID phone number in E.164 format.

        to_phone_number : str
            Destination phone number in E.164 format.

        token : typing.Optional[str]
            Optional session token used for STS authorization.

        downstream_websocket_url : typing.Optional[str]
            Optional downstream STS WebSocket URL to override the default.

        sip_auth_username : typing.Optional[str]
            SIP auth username, if your provider requires it.

        sip_auth_password : typing.Optional[str]
            SIP auth password, if your provider requires it.

        config : typing.Optional[OutboundCallConfig]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostConversationsSipOutboundCallResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "conversations/sip/outbound_call",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "token": token,
                "downstream_websocket_url": downstream_websocket_url,
            },
            json={
                "from_phone_number": from_phone_number,
                "to_phone_number": to_phone_number,
                "config": convert_and_respect_annotation_metadata(
                    object_=config, annotation=OutboundCallConfig, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
                "X-Sip-Address": str(sip_address) if sip_address is not None else None,
                "X-Sip-Auth-Username": str(sip_auth_username) if sip_auth_username is not None else None,
                "X-Sip-Auth-Password": str(sip_auth_password) if sip_auth_password is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostConversationsSipOutboundCallResponse,
                    parse_obj_as(
                        type_=PostConversationsSipOutboundCallResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_projects(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetProjectsResponse]:
        """
        Returns all projects in a workspace.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetProjectsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "projects",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProjectsResponse,
                    parse_obj_as(
                        type_=GetProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_projects(
        self, *, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PostProjectsResponse]:
        """
        Creates a new project in a workspace.

        Parameters
        ----------
        name : str
            The name of the project. Can only contain lowercase letters, numbers and hyphens. Must be unique within the workspace.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostProjectsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "projects",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostProjectsResponse,
                    parse_obj_as(
                        type_=PostProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_projects_name_or_id(
        self, name_or_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetProjectsNameOrIdResponse]:
        """
        Returns a project by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the project to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetProjectsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProjectsNameOrIdResponse,
                    parse_obj_as(
                        type_=GetProjectsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_projects_name_or_id(
        self, name_or_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteProjectsNameOrIdResponse]:
        """
        Deletes a project by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the project to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteProjectsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteProjectsNameOrIdResponse,
                    parse_obj_as(
                        type_=DeleteProjectsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def patch_projects_name_or_id(
        self,
        name_or_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        default_agent: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PatchProjectsNameOrIdResponse]:
        """
        Updates a project by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the project to update.

        name : typing.Optional[str]
            The name of the project. Can only contain lowercase letters, numbers and hyphens. Must be unique within the workspace.

        default_agent : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PatchProjectsNameOrIdResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            json={
                "name": name,
                "default_agent": default_agent,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PatchProjectsNameOrIdResponse,
                    parse_obj_as(
                        type_=PatchProjectsNameOrIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_projects_id_conversation_eval_prompts(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetProjectsIdConversationEvalPromptsResponse]:
        """
        Returns all conversation evaluation prompts for a project.

        Parameters
        ----------
        id : str
            The ID of the project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetProjectsIdConversationEvalPromptsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(id)}/conversation_eval_prompts",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProjectsIdConversationEvalPromptsResponse,
                    parse_obj_as(
                        type_=GetProjectsIdConversationEvalPromptsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_projects_id_conversation_eval_prompts(
        self, id: str, *, name: str, prompt: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PostProjectsIdConversationEvalPromptsResponse]:
        """
        Creates a new conversation evaluation prompt for a project.

        Parameters
        ----------
        id : str
            The ID of the project.

        name : str
            A useful name for referring to this prompt.

        prompt : str
            Actual evaluation prompt text to evaluate conversations with.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostProjectsIdConversationEvalPromptsResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"projects/{jsonable_encoder(id)}/conversation_eval_prompts",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            json={
                "name": name,
                "prompt": prompt,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostProjectsIdConversationEvalPromptsResponse,
                    parse_obj_as(
                        type_=PostProjectsIdConversationEvalPromptsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BasicError,
                        parse_obj_as(
                            type_=BasicError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
